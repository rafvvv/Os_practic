# операционные системы лекции

 15.01
#основные_понятия_и_функции_ОС

hardware (тех обесп) - процессор память монитор дисковые устройства
software (програмн обесп) - системное прикладное средства разработки 

| Пользователь |
| ---- |
| Прикладные программы |
| Системные программы |
| Операционная система |
| Техническое обеспечение |
#структура_вычислительной_системы

Прикладное ПО - к этому относится разнообразные банковские и прочие бизнес-программы, игры, текстовые процессоры и тд
Системное ПО - к этому относится программы сопутствующие функционированию и разработке прикладных программ.

ОС является частью системного ПО

#ОС_как_менеджер_ресурсов_обеспечивает:
- загрузку пользовательских программ в ОЗУ
- выполнение этих программ путём организации работы процессора
- работу с устройствами долговременной памяти, такими как магнитные диски ленты оптические диски и тд
- стандартный доступ к различным устройствам ввода/вывода (терминалы модемы печатающие устр-ва)
#основные_функции_ОС_как_защитника_полльзователей_и_програм :
- обеспечение сохранности инф на диске, т.е. защита от. удаления или повреждения чужих файлов
- защита от произвольного вмешательства в работу программ одних пользователей программ других пользователей
- пресечение попыток несанкционированного использования вычислительной сис
#уровни/виды_интерфейсов
1. пользовательский - предназначен для работы с готовыми приложениями
2. программный - интерфейс прикладного программирования, представляющий собой средства обращающиеся к возможностям ОС

- [ ] ОС - это комплекс программ, обесп возможность рационального исп оборудования и ПО удобным для пользователя образом 
- [ ] ОС - это система программ реализующая интерфейс между аппаратурой ЭВМ и пользователем
- [ ] ОС - это комплекс управляющих и обрабатывающих программ который выступает как интерфейс и как эффективного управления оборудования и ПО 

#эволюция_ОС
# 1-й период (1945-1995)
- ламповые машины
- нет разделения персонала
- нет ОС
- ввод программы с пульта или с колоды перфокарт
- отладка программы с пульта
- одновременное выполнение только одной программы
- появление прообразов первых компиляторов

# 2 период (1955-начало 60-х)
- компы на основе транзисторов
- снижение энергопотребления
- уменьшение размеров компов
- снижение стоимости их экслуатации и обслуживания

# 3.1 период (начало 60-х - 1980)
- компы на основе ИМС
- первые многозадачные пк
- рост  производительности процессоров
# 3.2 период
- магнитные диски
- мультипрограммирование
- защитные механизмы
# 3.3
- мультипрограммирование привело к изменению ОС
# 3.4
- элт дисплеи
- процессор переключается не только между операциями ввода/вывода

# 22.01
# 4 период (1980-е - наше время)
- Персональные компьютеры
- появление БИС
- удешевление и возрастание мощности
- пк стал бытовым прибором

#System_calls -интерфейс между ос и прикладной программой 
	- создают удаляют используют файлы и процессы
	перход задачи в превелегированный режим (kernel mode)
#hardwere_interputt - событие генерируемое внешним (по отношению к процессору) устройством

#Exception - возникает в результате выполнения программой недопустимой операции, доступак ресурсу при отсутствии необходимой привелегии или обращения к отсутствующей страницы памяти

#файл - часть пространства на носителе информации, имебщая имя

#файловая_система - скрывает особенности ввода-вывода и даёт программисту простую обстрактную модель файлов, независимую от устройств

# Операционные оболочки

	Операционная оболочка (operation shell) - комплекс программ, ориентированных наопределенную операционную систему предназначенный для облегчения диалога между пользователем и компьютером при выполнении определенных видов деятельности на компьютере.

	Оболочка ОС - интерпретатор команд операционной системы, обеспечивающий системы, интерфейс для взаимодействия пользователя с функциями системы.

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-01-22_12-58-27.jpg?raw=true)

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-01-22_13-03-24.jpg?raw=true)

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-01-22_13-09-19.jpg?raw=true)

# Виды вспомогательных модулей
- ﻿﻿Утилиты - программы, решающие отдельные задачи управления и сопровождения компьютерной системы (сжатие дисков, их проверка, дефрагментация; архивирование, сбор статистики и т.д.);
- ﻿﻿Системные обрабатывающие программы (загрузчики, отладчики, текстовые или графические редакторы);
- ﻿﻿Библиотеки процедур различного назначения для разработки приложений (математические функции, функции ввода-вывода и т.д.);
- ﻿﻿Программы, предоставляющие дополнительные услуги (калькулятор, некоторые игры).

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2024-01-22_13-22-00.jpg?raw=true)

# 29.01
## Монолитное ядро +/-
| плюсы | минусы |
| ---- | ---- |
|  Производительность - в виду того, что количество переключений из контекста режима пользователя в режим ядра сведено к минимуму. | Неустойчивость к сбоям - так как все базовые элементы и их работа выполняются в режиме ядра, и если хотя бы в одном модуле или блоке ядра произойдет какой-либо сбой, то ему будет подвержена вся ОС (все ядро), вариантов других нет, закончится все - перезапуском ОС.\| |
## Архитектура ОС, основанная на привилегированном ядре и приложениях пользовательского режима является КЛАССИЧЕСКОЙ = МНОГОСЛОЙНЫЙ ПОДХОД
- При таком подходе разработка системы осуществляется сверху вниз, от целей системы к их реализации.
- ﻿﻿Сначала определяются функции слоев и межслойные интерфейсы, задающие общую структуру системы, а затем разрабатываются модули внутри слоев.
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_2_2024-02-19_12-51-18.jpg?raw=true)

## Многослойная структура ядра ОС
- Многослойный подход применим и к структуре ядра как сложного многофункционального комплекса
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_3_2024-02-19_12-51-18.jpg?raw=true)

## РЕЗЮМЕ Многослойной / классической / многоуровневой архитектуры
- Все компоненты ОС разделяются на модули, выполняющие основные функции ОС (ядро), и модули, выполняющие вспомогательные функции ОС.
- Вспомогательные модули оформляются либо в виде приложений, либо в виде библиотек процедур и функций.
- Вспомогательные модули являются транзитными (загружаются в оперативную память только на время вышолнения). Модули ядра - резидентными (постоянно находящиеся в оперативной памяти).
- Устойчивость ОС повышается путем выполнения функций ядра в привилегированном режиме, а вспомогательных модулей ОС и пользовательских приложений - в пользовательском.
#### Многослойная классическая многоуровневая архитектура ОС 
#### ___не лишена своих проблем.___
1. Дело в том, что значительные изменения одного из уровней могут иметь трудно предвидимое влияние на смежные уровни.
2. Кроме того, многочисленные взаимодействия между соседними уровнями усложняют обеспечение безопасности.
Поэтому, как альтернатива классическому варианту архитектуры ОС, часто используется __МИКРОЯДЕРНАЯ__ архитектура ОС.

# МИКРОЯДРО / МИКРОЯДЕРНАЯ архитектура 
| Микроядро | • ядро, содержащее только самые необходимые функции. |
| ---- | ---- |
| Идея: | • минимизировать само ядро, вынести как можно функциональности в режим пользователя (т.е. исполнять эту функциональность в виде обычных процессов). |
| Многие сервисы становятся пользовательскими процессами: | • Драйверы устройств,<br><br>• Файловые системы,<br><br>• Менеджер виртуальной памяти,<br><br>• Оконные системы графического интерфейса пользователя,<br><br>• Службы безопасности<br><br>• Данный подход популяризован ядром МАСН («МАК»)<br><br>• На основе МАСН сделаны, среди прочих, Мас<br><br>OSX (комп.Apple), GNUHurd. |
# Суть МИКРОЯДЕРНОЙ архитектуры
- В привилегированном режиме остается работать только очень небольшая часть ОС, называемая микроядром.
- ﻿﻿Микроядро защищено от остальных частей ОС и приложений. В его состав входят машинно-зависимые модули, а также модули, выполняющие базовые механизмы обычного ядра.
- ﻿﻿Все остальные более высокоуровневые функции ядра оформляются как модули, работающие в пользовательском режиме. Так, менеджеры ресурсов, являющиеся неотьемлемой частью обычного ядра, становятся "периферийными" модулями, работающими в пользовательском режиме.
- ﻿﻿Таким образом, в архитектуре с микроядром традиционное расположение уровней по вертикали заменяется горизонтальным.
- ﻿﻿Между собой они взаимодействуют как равноправные партнеры с помощью обмена сообщениями, которые передаются через микроядро.
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_6_2024-02-19_12-51-18.jpg?raw=true)

#
# Многослойная структура ядра ОС
- Средства аппаратной поддержки ОС - аппаратные средства, прямо участвующие в организации вычислительных процессов: средства поддержки привилегированного режима, система прерываний, переключение контекстов процессов, трансляция адресов, защита памяти и т.п.
- Машино-зависимые модули - программные модули, в которых отображается специфика аппаратной платформы компьютера. В идеале этот слой полностью экранирует* вышележащие слои от особенностей аппаратуры, т.е. позволяет делать модули вышележащих слоев машинно-независимыми.
- ﻿﻿На уровне HAL работа с устройством определенного типа (накопитель, видеоплата, мышь и т.п.) всегда описывается при помощи одного и того же заранее определенного набора функций. В случае, если устройство имеет иной набор функций (например, устаревший 3d-ускоритель может не поддерживать многих современных функций), драйвер обязан эмулировать* стандартные функции с тем, чтобы ОС могла не заботиться о том, какое конкретно устройство установлено.

>﻿﻿Экранировать - предохранять от посторонних воздействий
> ﻿﻿Эмуляция - один из способов электронного архивирования устаревающих вычислительных систем.
- Базовые механизмы ядра. Модули этого слоя не принимают решений о распределении ресурсов, а только отрабатывают принятые на более высоком уровне решения. Выполняются наиболее примитивные операции ядра: программное переключение контекстов процессов, перемещение страниц между памятью и диском, диспетчеризация прерываний и т.п.
- ﻿﻿Менеджеры ресурсов. Модули этого уровня реализуют управление основными ресурсами системы. Группировка модулей в менеджеры обычно осуществляется по функциям основных подсистем ОС: выделяются менеджеры процессов, ввода-вывода и файловой системы (могут быть объединены), оперативной памяти.
- ﻿﻿Интерфейс системных вызовов. Взаимодействует непосредственно с приложениями и системными утилитами, образуя прикладной программный интерфейс ОС (API).

---
Загрузчик операционной системы - системное ПО, обеспечивающее загрузку операционной системы непосредственно после включения компьютера.

- ﻿﻿обеспечивает необходимые средства для диалога с пользователем компьютера (например, загрузчик позволяет выбрать ОС для загрузки);
- ﻿﻿приводит аппаратуру компьютера в состояние, необходимое для старта ядра ОС;
- ﻿﻿загружает ядро ОС в ОЗУ;
- ﻿﻿формирует параметры, передаваемые ядру ОС (например, ядру Linux передаются параметры, указывающие способ подключения корневой файловой системы);
- ﻿﻿передаёт управление ядру ОС. 
 
Базовая система ввода-вывода - набор программных средств, обеспечивающих взаимодействие ОС и приложений с аппаратными средствами. Обычно базовая система ввода-вывода представляет собой набор - драйверов.

Командный интерпретатор - необязательная, но присутствующая в большинстве операционных систем часть, которая обеспечивает управление системой посредством ввода текстовых команд.
Сервисное программное обеспечение - пакет приложений, включённый в состав операционной системы, реализующий множество полезных функций.

--- 
# Экзоядро ОС
Такое ядро ОС, которое предоставляет лишь функции взаимодействия процессов, безопасное выделение и распределение ресурсов. Доступ к устройствам на уровне контроллеров позволяет решать задачи, которые нехарактерны для универсальной ОС.

---
# Наноядро ОС
Такое ядро выполняет только единственную задачу-обработку аппаратных прерываний, образуемых устройствами ПК. После обработки наноядро посылает данные о результатах обработки далее идущему в цепи программному обеспечения при помощи той же системы прерываний.
Примером является KeyKOS - самая первая ОС на наноядре. Первая версия вышла ещё в 1983-м году.

---
# Гибридное ядро ОС
Модификация микроядер, позволяющая для ускорения работы впускать несущественные части в пространство ядра. На архитектуре гибкого ядра построены последние операционные системы от Windows, в том числе и Windows 7-10.

---
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_14_2024-02-19_12-51-18.jpg?raw=true)

---
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_15_2024-02-19_12-51-18.jpg?raw=true)

---
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_16_2024-02-19_12-51-18.jpg?raw=true)

---
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_17_2024-02-19_12-51-18.jpg?raw=true)

---
# 05.02
# Методы распределения памяти
Все алгоритмы распределения памяти разделены на два класса:
- ﻿﻿Алгоритмы, в которых используется перемещение сегментов процессов между оперативной памятью и диском;
- ﻿﻿Алгоритмы, в которых внешняя память не привлекается.

Алгоритмы, в которых внешняя память не привлекается:
- ﻿﻿Распределение памяти фиксированными разделами;
- ﻿﻿Распределение памяти динамическими разделами;
- ﻿﻿Распределение памяти перемещаемыми
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_3_2024-02-19_12-49-43.jpg?raw=true)

#  Распределение памяти динамическими разделами
- В этом случае память машины не делится заранее на разделы.
- ﻿﻿Сначала вся память, отводимая для приложений, свободна.
- ﻿﻿Каждому вновь поступающему на выполнение приложению на этапе создания процесса выделяется вся необходимая ему память (если достаточный объем памяти отсутствует, то приложение не принимается на выполнение и процесс для него не создается).
- ﻿﻿После завершения процесса память освобождается, и на это место может быть загружен другой процесс.
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_5_2024-02-19_12-49-43.jpg?raw=true)

# Распределение памяти перемещаемыми разделами
- ﻿﻿Одним из методов борьбы с фрагментацией является перемещение всех занятых участков в сторону старших или младших адресов, так, чтобы вся свободная память образовала единую свободную область.
- ﻿﻿В дополнение к функциям, которые выполняет ОС при распределении памяти динамическими разделами в данном случае она должна еще время от времени копировать содержимое разделов из одного места памяти в другое, корректируя таблицы свободных и занятых областей - процедура называется сжатием.
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_7_2024-02-19_12-49-43.jpg?raw=true)

---
Для преодоления перегрузки памяти были выработаны два основных подхода.
- ﻿﻿1. Самый простой из них, называемый свопингом, заключается в размещении в памяти всего процесса целиком, в запуске его на некоторое время, а затем в сбросе его на диск. Бездействующие процессы большую часть времени хранятся на диске и в нерабочем состоянии не занимают пространство оперативной памяти.
- ﻿﻿2. Второй подход называется виртуальной памятью, он позволяет программам запускаться даже в том случае, если они находятся в оперативной памяти лишь частично.

# Виртуальная память
Виртуальная память - это подход к управлению памятью компьютером, который скрывает физическую память (в различных формах, таких как: оперативная память или жесткие диски) за единым интерфейсом, позволяя создавать программы, которые работают с ними как с единым непрерывным массивом памяти с произвольным доступом.
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_9_2024-02-19_12-49-43.jpg?raw=true)

- Виртуальная память - метод управления памятью, которая реализуется с использованием аппаратного и программного обеспечения компьютера.
- ﻿﻿Она отображает используемые программами виртуальные адреса в физические адреса в памяти компьютера.
- ﻿﻿Основная память представляется в виде непрерывного адресного пространства или набора смежных непрерывных сегментов.

К основным преимуществам виртуальной памяти относят:
- ﻿﻿Избавление программиста от необходимости управлять общим пространством памяти,
- ﻿﻿Повышение безопасность использования программ за счет выделения памяти,
- ﻿﻿Возможность иметь в распоряжении больше памяти, чем это может быть физически доступно на компьютере.

Виртуальная память делает программирование приложений проще:
- ﻿﻿Скрывая фрагментацию физической памяти;
- ﻿﻿Устраняя необходимость в программе для обработки наложений в явном виде;
- ﻿﻿Когда каждый процесс запускается в своем собственном выделенном адресном пространстве, нет необходимости переместить код программы или получить доступ к памяти с относительной адресацией.

# Страничное распределение
- При таком способе все фрагменты программы, на которые она разбивается (кроме последней части) получаются одинаковыми.
- ﻿﻿Одинаковыми должны быть и единицы памяти предоставляемые для размещения фрагментов программы.

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_14_2024-02-19_12-49-43.jpg?raw=true)
- Когда программа ссылается на часть своего адресного пространства, находящегося в физической памяти, то операция выполняется сразу.
# Страничная организация памяти
С точки зрения программиста:
- ﻿﻿Процессам виртуальное адресное пространство представляется непрерывным, от байта 0 до байта N
- ﻿﻿N зависит от аппаратной поддержки (например 32бит. - адр.пространство 4Гб), делится соответственно.
- ﻿﻿В реальности виртуальные страницы распределены по страницам физической памяти далеко не непрерывно и не один к одному.
- ﻿﻿Это два разных мира - физические страницы и виртуальные страницы.

# 12.02
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_1_2024-02-19_12-47-42.jpg?raw=true)

- Страничный способ организации виртуальной памяти - способ разрывного размещения задач в памяти, при котором все фрагменты задачи имеют одинаковый размер, кратный степени двойки (для использования операции конкатенации).

___Виртуальный адрес состоит из двух полей:___
- ﻿﻿Указатель на часть программы (с которой идет работы) для определения местоположения этой части;
- ﻿﻿Относительный адрес нужного фрагмента памяти (по отношению к найденному адресу).

# Трансляция адресов
Трансляция виртуального адреса:
- ﻿﻿Виртуальный адрес состоит из двух частей: номер виртуальной страницы (VPN) и смещение внутри страницы
- ﻿﻿Номер виртуальной страницы (VPN- virtual page number) это индекс в таблице страниц (Pagetable)
- ﻿﻿Запись в таблице страниц (РТЕ - page table entry) содержит номер фрейма (PFN -page frame number)
- ﻿﻿Фрейм - это страница физической памяти.
- ﻿﻿Номер фрейма (PFN) - это номер физической страницы.
- Смысл таблицы страниц - одна запись в таблице страниц (РТЕ) на одну страницу виртуального адресного пространства (VPN), отображает VPN на PFN. Какая виртуальная страница соответствует какому фрейму физической памяти.
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_6_2024-02-19_12-47-42.jpg?raw=true)

# Таблица страниц
Запись в таблице - дескриптор страницы
- ﻿﻿Номер физической страницы, в которую загружена данная виртуальная страница;
- ﻿﻿Признак присутствия = 1, если виртуальная страница находится в ОП;
- ﻿﻿Признак модификации страницы → 1, когда производится запись по адресу, относящемуся к данной странице;
- ﻿﻿Признак обращения (бит доступа) → 1, при каждом обращении по адресу, относящемуся к данной странице;

# Страничное прерывание
- ﻿﻿Номер виртуальной страницы → определяется нужный элемент таблицы страниц → извлечение информации о станице (в том числе адрес в ОП)
- ﻿﻿Анализ признака присутствия, если страница в ОП есть → преобразование адреса (ВА - ФА), если страницы нет, то страничное прерывание (действия)
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_9_2024-02-19_12-47-42.jpg?raw=true)

Это происходит в два этапа:
- ﻿﻿Посредством системы программирования;
- ﻿﻿Посредством операционной системы (с помощью специальных программных модулей управления памятью и использования соответствующих аппаратных средств вычислительной системы).
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_11_2024-02-19_12-47-42.jpg?raw=true)

- Страничная память — способ организации виртуальной памяти, при котором единицей отображения виртуальных адресов на физические является фрагмент постоянного размера — страница.
- ﻿﻿При использовании страничной модели вся виртуальная память делится на N страниц таким образом, что часть виртуального адреса интерпретируется как номер страницы, а часть — как смещение внутри страницы.
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_13_2024-02-19_12-47-42.jpg?raw=true)

# Сегментное распределение - вывод
- ﻿﻿Сегментная организация виртуальной памяти реализует следующий механизм: вся память делиться на сегменты фиксированной или произвольной длины, каждый из которых характеризуется своим начальным адресом.
- ﻿﻿Виртуальный адрес в такой системе состоит из 2-х компонент: базы сегмента, к которому мы хотим обратиться, и смещения внутри сегмента.
# Странично-сегментное распределение
- ﻿﻿Данный метод представляет собой комбинацию страничного и сегментного распределения памяти и, вследствие этого, сочетает в себе достоинства обоих ПоДХодоВ.
- ﻿﻿Виртуальное пространство процесса делится на сегменты, а каждый сегмент в свою очередь делится на виртуальные страницы, которые нумеруются в пределах сегмента.
- ﻿﻿Оперативная память делится на физические страницы.

# Методы распределения памяти без использования внешней памяти:
- ﻿﻿Распределение памяти фиксированными разделами.
- ﻿﻿Распределение памяти разделами переменной величины.
- ﻿﻿Перемещаемые разделы.
__Если достаточный объем памяти отсутствует, то задача не принимается на выполнение и стоит в очереди. После завершения задачи память освобождается, и на это место может быть загружена другая задача.__
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_3_2024-02-19_13-48-53.jpg?raw=true)

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_4_2024-02-19_13-48-53.jpg?raw=true)


---
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_5_2024-02-19_13-48-53.jpg?raw=true)

# Введение в Docker
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_6_2024-02-19_13-48-53.jpg?raw=true)

![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_7_2024-02-19_13-48-53.jpg?raw=true)

# Для чего нужен (или плюсы):
1. ﻿﻿﻿Изолированный запуск приложений в контейнерах.
2. ﻿﻿﻿Упрощение разработки, тестирования и деплоя приложении.
3. ﻿﻿﻿Отсутствие необходимости конфигурировать среду для запуска - она поставляется вместе с приложением - в контейнере.
4. ﻿﻿﻿Упрощает масштабируемость приложений и управление их работой с помощью систем оркестрации контейнеров.
## Из чего состоит?
1. ﻿﻿﻿Образы
2. ﻿﻿﻿Контейнеры
3. ﻿﻿﻿Volumes
4. ﻿﻿﻿Networks
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_9_2024-02-19_13-48-53.jpg?raw=true)

## Образ
- Read-only шаблон с набором инструкций, предназначенных для создания контейнера
- ﻿﻿Образ состоит из неизменяемых слоев, каждый из которых добавляет/удаляет/изменяет файлы из предыдущего слоя.
- ﻿﻿Неизменяемость слоев позволяет их использовать совместно в разных образах.
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_10_2024-02-19_13-48-53.jpg?raw=true)

# Что делает docker при запуске образа?

```
$ docker run --rm -p 8888:80 nginx
```

- ﻿﻿скачивает образ
- ﻿﻿создает контейнер
- ﻿﻿инициализирует файловую систему и монтирует read-only образ
- ﻿﻿инициализирует сеть/ мост
- ﻿﻿запускает указанный процесс
- ﻿﻿обрабатывает и выдает вывод приложения
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_12_2024-02-19_13-48-53.jpg?raw=true)

__При сегментно-страничном способе организации виртуальной памяти программа разбивается на логически законченные части - сегменты, виртуальный адрес содержит указание на номер соответствующего сегмента.__
![](https://github.com/rafvvv/Os_practic/blob/main/photos/photo_14_2024-02-19_13-48-53.jpg?raw=true)

# Виртуальный адрес можно представить состоящим из двух полей:
- ﻿указатель на часть программы (с которой идет работы) для определения местоположения этой части;
- ﻿относительный адрес нужной ячейки памяти (по отношению к найденному адресу).
# Подсистема управления памятью в этом случае выполняет следующие задачи:
- ﻿﻿сравнивая размер программы, поступившей на выполнение, и свободных разделов, выбирает подходящий раздел,
- ﻿﻿осуществляет загрузку программы и настройку адресов.

# При распределение памяти разделами переменной величины память машины не делится заранее на разделы. Сначала вся память свободна. Каждой вновь поступающей задаче выделяется необходимая ей память.
__Виртуальное адресное пространство зависит от:__
- ﻿﻿Архитектуры процессора;
- ﻿﻿Системы программирования.
__Виртуальное адресное пространство не зависит от:__
- Объема реальной физической памяти, установленной в компьютере.
#  Все методы управления памятью могут быть разделены на два класса:
- ﻿﻿методы, которые используют перемещение процессов между оперативной памятью и диском,
- ﻿﻿методы, которые не делают этого.
# Методы распределения памяти без использования внешней памяти:

- ﻿﻿Распределение памяти фиксированными разделами.
- ﻿﻿Распределение памяти разделами переменной величины.
- ﻿﻿Перемещаемые разделы.
